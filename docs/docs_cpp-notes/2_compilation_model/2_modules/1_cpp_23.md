---
title: C++23
date: 2025-12-12T03:12:33.331Z
tags:
  - cpp
categories:
  - cpp
slug: "23"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The inclusion model (`#include`) has defined C++ physical architecture for decades. It relies on textual substitution, resulting in fragile builds, macro leakage, and redundant parsing of the same header millions of times across a project, precompile headers is a workaround but not a solution.

The **Module System** aims replaces this with a import model. A module is compiled once into a binary representation (Binary Module Interface - BMI). Consumers import this semantic representation directly, bypassing the preprocessor. Keep in mind that moduels are only partially implemented in most compilers.

This module details the physical structure of a modular C++ project, focusing on the hierarchy of units: **Primary Interfaces**, **Partitions**, and **Implementation Units**.

## 1. The Primary Module Interface Unit (PMIU)

Every module must have exactly one **Primary Module Interface Unit**. This is the root of the module. It defines the exported API that consumers see when they run `import ModuleName;`.

### Syntax and Structure

A PMIU is characterized by the `export module [Name];` declaration at the start of the file.

```cpp
// File: src/engine.cppm
export module Engine; // Declaration of the module name

// Optional: Import other modules
import std;

// Exported Symbol: Visible to importers
export namespace Engine {
    class Context {
    public:
        void initialize();
    };

    export int version = 1;
}

// Non-Exported Symbol: Visible only within this module's units
// (Internal Linkage logic applies differently in modules, termed "Module Linkage")
void internal_helper() {}
```

### File Extensions

The C++ standard does not mandate file extensions, but tooling conventions have emerged:

- **Clang/LLVM:** `.cppm` (Recommended)
- **MSVC:** `.ixx`
- **GCC:** `.cpp` (Requires specific flags to distinguish from sources)

## 2. Module Implementation Units (MIU)

Implementation Units contain the code that fulfills the promises made in the Interface. They allow for the separation of definition and implementation, similar to the `.h` vs `.cpp` split, but with stronger isolation.

An MIU allows you to modify the implementation details of a function _without_ changing the Interface BMI. This prevents downstream recompilation avalanches.

### Syntax

An MIU starts with `module [Name];`. Note the lack of the `export` keyword.

```cpp
// File: src/engine_impl.cpp
module Engine; // Declares this file belongs to the 'Engine' module

// Implicitly imports the Primary Interface of 'Engine'.
// We can see 'Context' definition without importing anything.

namespace Engine {
    void Context::initialize() {
        // Implementation logic
    }
}
```

- **Constraint:** Implementation Units cannot export anything. Their sole purpose is to define entities declared in the interface or to implement internal logic.

## 3. Module Partitions

For large modules, putting the entire API surface into a single `.cppm` file is unmanageable. **Partitions** allow you to split the module definition across multiple files while presenting a unified view to the consumer.

Partitions are internal organizational details. A consumer cannot import a partition directly (e.g., `import Engine:Graphics` is illegal outside the module).

### 3.1 Interface Partitions (`:Name`)

An interface partition contributes to the public API of the module. It must be re-exported by the Primary Interface.

**File:** `src/engine_graphics.cppm`

```cpp
export module Engine:Graphics; // Colon denotes partition

export namespace Engine {
    struct Renderer {
        void draw();
    };
}
```

**File:** `src/engine_physics.cppm`

```cpp
export module Engine:Physics;

export namespace Engine {
    struct Collider {
        bool check();
    };
}
```

**File:** `src/engine.cppm` (Primary Interface)

```cpp
export module Engine;

// Re-export partitions to compose the single 'Engine' module
export import :Graphics;
export import :Physics;

// Now a user importing 'Engine' gets both Renderer and Collider.
```

### 3.2 Implementation Partitions

Sometimes internal implementation logic is too large for one file but needs to be shared among different units of the module. Implementation partitions are _not_ exported and are _not_ reachable by consumers.

**File:** `src/engine_internals.cppm`

```cpp
module Engine:Internals; // Note: No 'export' keyword before 'module'

namespace Engine::Detail {
    // Shared internal logic
    void low_level_alloc() { ... }
}
```

**File:** `src/engine.cpp` (Implementation Unit)

```cpp
module Engine;
import :Internals; // Import the internal partition

void use_allocator() {
    Engine::Detail::low_level_alloc();
}
```

## 4. The Global Module Fragment (GMF)

The C++ ecosystem relies heavily on legacy headers (`<unistd.h>`, `<windows.h>`). Modules provide a mechanism called the **Global Module Fragment** to safely include these headers without contaminating the module's symbol table or exporting macros unintentionally.

The GMF must appear before the module declaration.

```cpp
module; // Start of Global Module Fragment

// Headers included here behave as if included in a standard TU.
// Their macros and declarations are visible to the module code below.
#include <sys/socket.h>
#include <openssl/ssl.h>

export module Network; // End of GMF, Start of Module

import std;

export namespace Network {
    // We can use types from sys/socket.h here
    void connect(sockaddr_in* addr) {
        // ...
    }
}
```

**Architecture Rule:** Never `#include` a header inside the module body (after `export module`). Always place includes in the GMF or `import` them if they are modularized headers.

## 5. Architectural Summary: The Module DAG

When designing a module system, visualize the dependencies as a Directed Acyclic Graph (DAG).

| Component                    | Syntax                  | Role                             | Visibility           |
| :--------------------------- | :---------------------- | :------------------------------- | :------------------- |
| **Primary Interface**        | `export module A;`      | The Root. Defines public API.    | Visible to World     |
| **Interface Partition**      | `export module A:Part;` | API Fragment. Composes the Root. | Visible to Module A  |
| **Implementation Unit**      | `module A;`             | Compilable logic. PIMPL.         | Internal to Module A |
| **Implementation Partition** | `module A:Part;`        | Shared internal logic.           | Internal to Module A |

### Reachability vs. Visibility

- **Visibility:** Can name lookup find the symbol? (Controlled by `export`).
- **Reachability:** Is the semantic property of the symbol available? (Controlled by `import`).

In C++23 modules, a type can be _reachable_ but not _visible_. For example, if a function returns a `struct` that is not exported, the caller can use the struct (store it via `auto`), but cannot name the type explicitly.

## Build System Implications

Modules fundamentally change the build dependency graph.

1. **Scanning:** The build system (CMake/Ninja) must scan source files _before_ compilation to discover module names and dependencies. Implicit file-to-target mapping is no longer sufficient.
2. **Ordering:** If `B.cppm` imports `A.cppm`, `A` must be compiled (to generate the BMI) before `B` can be compiled. This serialization eliminates parallel compilation of dependent interfaces, though Implementation Units can still compile in parallel.
