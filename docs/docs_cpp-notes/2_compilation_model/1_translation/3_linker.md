---
title: Linker
date: 2025-12-11T23:31:53.376Z
tags:
  - cpp
categories:
  - cpp
slug: linker
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Linker (`ld`, `lld`, `link.exe`) is the final architect of the binary. While the compiler works in isolation on Translation Units (TUs), generating "relocatable object files," the linker is responsible for fusing these fragments into a coherent executable memory map.

It performs three critical atomic operations:

1. **Resolution:** Matching "Use" sites (Undefined symbols) to "Definition" sites.
2. **Relocation:** Patching code sections with concrete memory addresses.
3. **Deduplication:** Discarding redundant code generated by templates and inline functions.

## 1. Symbol Resolution

Input object files contain a **Symbol Table**. The linker aggregates these tables into a Global Symbol Table.

### The Resolution State Machine

The linker maintains three sets:

- **E (Executable):** The accumulated object files to be output.
- **U (Undefined):** References to symbols currently missing a definition.
- **D (Defined):** Symbols defined in **E**.

As the linker scans inputs (objects and libraries) from **left to right** on the command line:

1. If input is an **Object File (`.o`)**: It adds the file to **E**. It adds new definitions to **D** and resolves matching entries in **U**. Any new undefined references in the object are added to **U**.
2. If input is a **Static Library (`.a`)**: The linker checks if any symbol in the library's member objects matches a symbol currently in **U**.
   - If a match is found, that specific member object is extracted and added to **E**.
   - If no match is found, the member object is ignored entirely.

:::danger The Archive Order Trap
Because static libraries are searched only to resolve _currently pending_ undefined symbols, order matters.
If `LibA` depends on `LibB`, `LibA` must appear **before** `LibB` in the linker command.

- Correct: `clang++ main.o -lA -lB`
- Incorrect: `clang++ main.o -lB -lA` (Linker fails: Symbols in A are undefined).
  :::

### Weak vs. Strong Symbols

- **Strong:** Functions and initialized globals. Only one allowed (ODR).
- **Weak:** Uninitialized globals, or symbols explicitly marked `__attribute__((weak))`.
- **Rule:** A Strong symbol overrides a Weak symbol. Multiple Weak symbols are permitted (linker picks an arbitrary one). This is often used for glibc stub functions.

## 2. Relocation

Compilers generate object code assuming a start address of `0x0`. Instructions referring to data or other functions use placeholder values. **Relocation** is the process of patching these placeholders with actual addresses once the final memory layout is determined.

### Relocation Entries

The compiler generates a `.rela.text` section containing instructions for the linker.

- _Instruction:_ "At offset `0x42` in section `.text`, insert the difference between the address of symbol `foo` and the current instruction pointer (RIP)."

### Relocation Types (x86_64)

1. **R_X86_64_PC32 (Relative):**
   Used for function calls (`call`) and data access (`lea`) within the same binary. The value patched is $S + A - P$ (Symbol + Addend - Place). This enables **Position Independent Code (PIC)**, allowing the binary to be loaded at any virtual address (ASLR).

2. **R_X86_64_64 (Absolute):**
   Used for static data pointers (e.g., jump tables). Requires load-time patching if the binary base address changes.

### The PLT and GOT (Dynamic Linking)

When code references a symbol in a _Shared Library_ (`.so`), the address is unknown until runtime. The linker cannot patch the code directly. Instead, it generates:

- **Global Offset Table (GOT):** A data section (`.got`) acting as a directory of addresses.
- **Procedure Linkage Table (PLT):** A code section (`.plt`) containing stubs.

**Mechanism:**

1. Code calls `printf` (in libc).
2. The call jumps to `printf@plt` (stub).
3. The stub jumps to the address stored in `printf@got`.
4. Lazy Binding: Initially, the GOT points back to the dynamic linker resolver. On the first call, the resolver finds the actual `printf` address, updates the GOT, and executes the function. Subsequent calls jump directly.

## 3. Deduplication (COMDAT Folding)

C++ templates pose a unique challenge. If `std::vector<int>::push_back` is instantiated in `A.cpp` and `B.cpp`, both object files contain the machine code for that function. Naively linking them would result in a "Multiple Definition" error.

### COMDAT Sections

The compiler marks template instantiations and `inline` functions with a special flag: **COMDAT** (Common Block).

- **Rule:** "This section defines symbol X. If you have already seen a COMDAT for X, discard this section. If not, keep it."
- **Result:** The final binary contains exactly one copy of the template code.

### Identical Code Folding (ICF)

Modern linkers (Gold, LLD, Mold) go further. They detect functions that are distinct in C++ but compile to identical machine code.

**Example:** `std::vector<int>` and `std::vector<long>` on a 64-bit platform often generate identical instructions (since `int` and `long` may both be passed in 64-bit registers).

**ICF Mechanism:**

1. The linker hashes the `.text` content of every section.
2. If hashes match, it performs a byte-by-byte comparison.
3. If identical, it keeps one copy and updates the symbol table so both `vector<int>::push_back` and `vector<long>::push_back` point to the same address.

**CMake Configuration:**

```cmake
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
    # Enable ICF on LLD/Gold
    add_link_options("-Wl,--icf=all")
endif()
```

## 4. Name Demangling

The linker operates on **Mangled Names** (decorated names that encode namespace, class, and argument types).

- **Source:** `void foo::bar(int)`
- **Mangled (Itanium):** `_ZN3foo3barEi`

Linker errors report the mangled name, which is unreadable. Tools like `c++filt` translate them back.

**Diagnostic Workflow:**

1. **Error:** `undefined reference to _ZN3foo3barEi`
2. **Demangle:**

   ```bash
   c++filt _ZN3foo3barEi
   # Output: foo::bar(int)
   ```

3. **Inspect:** Use `nm` to find which object file provides (or fails to provide) the symbol.

   ```bash
   nm -C --defined-only libfoo.a | grep "foo::bar"
   ```

## Architectural Summary

| Process           | Input              | Action                                         | Output                  |
| :---------------- | :----------------- | :--------------------------------------------- | :---------------------- |
| **Resolution**    | Symbol Tables      | Match `U` (Undefined) to `D` (Defined).        | Global Symbol Table     |
| **Deduplication** | COMDAT Sections    | Discard duplicate template instantiations.     | Unique Code Sections    |
| **Layout**        | Sections           | Concatenate `.text`, `.data` from all objects. | Virtual Address Map     |
| **Relocation**    | Relocation Entries | Patch placeholders with virtual addresses.     | Executable Machine Code |
