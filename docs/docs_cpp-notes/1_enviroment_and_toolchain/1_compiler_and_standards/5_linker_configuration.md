---
title: Linker Configuration
date: 2025-12-10T05:29:40.734Z
tags:
  - cpp
categories:
  - cpp
slug: linker-configuration
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The linker is the final stage of the translation pipeline. It accepts object files (`.o` or `.obj`) generated by the compiler, resolves symbol references (functions and variables), performs relocation, and generates the final executable or shared library.

In C++23 development, the default system linker is often the bottleneck for build iteration speeds. Replacing legacy linkers (like GNU BFD) with modern asynchronous linkers (LLD or Mold) can reduce incremental link times by an order of magnitude.

## The Landscape of Linkers

### 1. GNU ld.bfd

- **Status:** Legacy Default.
- **Platform:** Linux/GNU.
- **Characteristics:** Extremely stable but single-threaded and slow. It uses low-memory algorithms designed for hardware from the 1990s.

### 2. GNU gold

- **Status:** Maintenance Mode / Deprecated.
- **Platform:** Linux (ELF only).
- **Characteristics:** The first mainstream linker designed for C++. It introduced multithreading but has largely been superseded by LLD.

### 3. LLVM LLD

- **Status:** Industry Standard Best Practice.
- **Platform:** Cross-Platform (ELF, COFF, Mach-O, Wasm).
- **Characteristics:**
  - Drop-in replacement for system linkers.
  - Highly parallelized.
  - Typically 2x-10x faster than BFD.
  - Required for correct Cross-Compilation with Clang.

### 4. Mold

- **Status:** High-Performance / Bleeding Edge.
- **Platform:** Linux (ELF), partial macOS/Windows support.
- **Characteristics:** Designed to utilize all available CPU cores and IO bandwidth. It aims to make linking as fast as file copying (`cp`). It is significantly faster than LLD on large projects.

### 5. MSVC link.exe

- **Status:** Windows Default.
- **Platform:** Windows (COFF).
- **Characteristics:** Tightly integrated with PDB generation and Incremental Linking. While LLD (`lld-link`) is faster, `link.exe` is required for certain "Edit and Continue" debugging features in Visual Studio.

---

## CMake Configuration Strategy

Configuring the linker requires instructing the compiler driver (e.g., `clang++` or `g++`) to invoke a specific underlying binary.

### Modern CMake (Version 3.29+)

CMake 3.29 introduced a generic abstraction for selecting linkers, removing the need for compiler-specific flag handling.

```cmake
cmake_minimum_required(VERSION 3.29)
project(HighPerfCpp)

add_executable(app main.cpp)

# Select linker by type
# Options: LLD, MOLD, APPLE_CLASSIC, MSVC, GNU, GOLD
set_property(TARGET app PROPERTY LINKER_TYPE LLD)
```

### Legacy CMake (Pre-3.29)

For older CMake versions, linker flags must be manually injected.

```cmake
# Check if using Clang or GCC
if (CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
    include(CheckCXXCompilerFlag)

    # Attempt to use Mold
    check_cxx_compiler_flag("-fuse-ld=mold" HAVE_MOLD)
    if (HAVE_MOLD)
        add_link_options("-fuse-ld=mold")
    else()
        # Fallback to LLD
        check_cxx_compiler_flag("-fuse-ld=lld" HAVE_LLD)
        if (HAVE_LLD)
            add_link_options("-fuse-ld=lld")
        endif()
    endif()
endif()
```

---

## Link Time Optimization (LTO)

Link Time Optimization (also known as IPO - Interprocedural Optimization) allows the compiler to perform optimizations across translation unit boundaries. Instead of generating machine code in the `.o` files, the compiler generates intermediate bitcode (IR). The linker then merges all IR and runs the optimizer on the entire program at once.

### Benefits

- **Inlining:** Functions defined in `math.cpp` can be inlined into `main.cpp`.
- **Dead Code Elimination:** Unused parts of libraries can be aggressively stripped.

### Costs

- **Build Time:** Link time increases drastically (often becoming single-threaded).
- **Memory:** High RAM usage during linking.

### Enabling LTO in CMake

CMake provides a portable abstraction for enabling LTO.

```cmake
include(CheckIPOSupported)
check_ipo_supported(RESULT result OUTPUT output)

if(result)
    set_property(TARGET app PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)
else()
    message(WARNING "IPO is not supported: ${output}")
endif()
```

### ThinLTO (Clang/LLVM)

Standard LTO is monolithic. Clang supports **ThinLTO**, which parallelizes the LTO process, offering similar runtime performance with significantly faster build times.

To force ThinLTO specifically when using Clang:

```cmake
if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    add_compile_options(-flto=thin)
    add_link_options(-flto=thin)
endif()
```

---

## Symbol Stripping

For release builds, removing debug symbols reduces binary size significantly.

### Linux/macOS

The `strip` utility removes symbols.

```cmake
if (UNIX AND NOT APPLE)
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s")
endif()
```

### Windows (MSVC)

Windows separates debug symbols into a `.pdb` file. The executable is stripped by default in Release mode.

---

## Verification

To verify which linker is being used, inspect the verbose output of the build system.

1. **Configure CMake with Verbose Output:**

   ```bash
   cmake -S . -B build -DCMAKE_VERBOSE_MAKEFILE=ON
   ```

2. **Build and Inspect:**

   ```bash
   cmake --build build
   ```

3. **Analyze the Link Command:**
   Look for the final linking step in the log.
   - **LLD:** Will show `-fuse-ld=lld` or direct calls to `ld.lld`.
   - **Mold:** Will show `-fuse-ld=mold` or direct calls to `mold`.
   - **BFD:** Usually invoked as just `ld` (check `ld --version` to confirm).

### ELF Verification (Linux)

Use `readelf` to check the `.comment` section of the resulting binary, which often contains the linker signature.

```bash
readelf -p .comment build/app
```

**Target Output (Example):**

```text
String dump of section '.comment':
  [     0]  Linker: LLD 16.0.0
  [    1c]  clang version 16.0.0
```
